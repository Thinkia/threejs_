<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>综合测试练习</title>

    <style>
        body{
            margin:0;
            overflow:hidden;
        }
    </style>

</head>
<body>
    <script type="text/javascript"  src="../main/three.js"></script>

    <script type="text/javascript"  src="../lib/js/loaders/OBJLoader.js"></script>
    <script type="text/javascript"  src="../lib/js/loaders/MTLLoader.js"></script>
    <script type="text/javascript"  src="../lib/js/loaders/DDSLoader.js"></script>
    <script type="text/javascript"  src="../lib/js/loaders/ColladaLoader.js"></script>

    <script type="text/javascript"  src="../lib/js/controls/OrbitControls.js"></script>

    <script type="text/javascript"  src="../lib/js/Detector.js"></script>
    <script type="text/javascript"  src="../lib/js/libs/stats.min.js"></script>

    <script type="text/javascript"  src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

    <script type="text/javascript"  src="../lib/js/libs/tween.min.js"></script>

    <script type="text/javascript"  src="../lib/js/TypedArrayUtils.js"></script>

    <script>


        var rayPoint = new Array();                                                                                     //     射线源

        var positions = new Float32Array(8*3);                                                                          //     8个三维坐标
        var kdtree ;                                                                                                    //   KD-Tree


        //构造三维对象
        var lookAt = new  THREE.Vector3();

        var lookatx=0,lookaty=0,lookatz=0;

        var xchange=0,zchange=0;


        $(function () {
            $.ajax(
                {
                    type:"post",
                    url:"src/VT_Model_info.json",
                    dataType:"json",
                    success:function(result){

                        addBox(result);
                    }
                }

            );
        });
                                                                                                                             // ajax  提取  json 数据函数   ---   jq
        function addBox(result){
            var i=0;
            console.log("射线源：");
            $.each(result,function(index,obj)
                {
                    i++;
                    if(i==5) {
                        for (var j = 0; j < obj[0].length; j++) {
                           // console.log("初始:"+obj[0][j]['matrix'][3]+","+obj[0][j]['matrix'][7]+","+obj[0][j]['matrix'][11] );
                            rayPoint[j]=new THREE.Vector3(obj[0][j]['matrix'][3],obj[0][j]['matrix'][7],obj[0][j]['matrix'][11]);               //将json  4*4变换矩阵中3，7，11 坐标保存到 rayPoint数组

                            rayPoint[j].applyAxisAngle(new THREE.Vector3(1,0,0),Math.PI/2);                                                     // applyAxisAngle() 实现 绕（1，0，0）向量    旋转  pi/2

                           // console.log("变换后:"+rayPoint[j].x+","+rayPoint[j].y+","+rayPoint[j].z);
                            /*           实现了相机自传            未实现 相机绕x轴转
                            //console.log(rayPoint[j]+"----"+j);
                            var cube = new THREE.PerspectiveCamera();
                            cube.position.set( rayPoint[j].x,rayPoint[j].y,rayPoint[j].z );
                            console.log(cube.position);
                            cube.applyAxisAngle(new THREE.Vector3(1,0,0),Math.PI/2);
                            console.log("旋转后："+cube.position.x+","+cube.position.y+","+cube.position.z);
                                */


                        }
                    }
                }
            );
        }



        var container;
        var camera,scene,renderer,camera1;
        var helper;
        var helperSphere;
        var mesh;
        var controls;

        var targetX=0,targetY=0,targetZ=0;


        var mouse = new THREE.Vector2();
        var raycaster = new THREE.Raycaster()

       // var   rayOrigin = new THREE.Vector3(0,0,0);    //  射线源点

        var   rayDirection = new THREE.Vector3(0,-1,0);   // 射线方向              xy面法向量

        init();
        animate();

        function init(){

            container = document.createElement('div');
            document.body.appendChild( container );

            camera = new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,1,2000);

            camera1 = new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,1,2000);  //过渡相机


            // camera.position.z = -50;
          //  camera.position.y = -100;

            camera.position.set(1.916,6.143,17.256);                                                                    //  相机初始位置

            camera1.position.set(1.916,6.143,17.256);                                                                   //  过渡相机初始位置



            scene = new THREE.Scene();

            var ambientLight = new THREE.AmbientLight(0xcccccc,0.4);

            scene.add(ambientLight);

            var pointLight = new THREE.PointLight(0xffffff,0.8);

            camera.add(pointLight);
            scene.add(camera);

            var onProgress = function (xhr){
                if(xhr.lengthComputable){
                    var percentComplete = xhr.loaded/xhr.total*100;
                    console.log( Math.round(percentComplete,2)+'% downloaded');
                }
            };

            var onError = function(xhr){ };

            THREE.Loader.Handlers.add(/\.dds$/i,new THREE.DDSLoader());

            var mtlLoader = new THREE.MTLLoader();
            mtlLoader.setPath('src/floor3/');
            mtlLoader.load('VT_Model.mtl',function (materials) {

                materials.preload();

                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('src/floor3/');
                objLoader.load('VT_Model.obj', function (object) {                                                     //模型

                    mesh = object;  // 获取obj 对象 并保存

                    mesh.rotation.x = Math.PI / 2;                                                                       //模型绕x轴旋转  pi/2
                    scene.add(object);
                }, onProgress, onError);

            });


            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth,window.innerHeight);
            container.appendChild(renderer.domElement);

            //helper

            var gridHelper = new THREE.GridHelper(10,20);
           // scene.add(gridHelper);                                                                                     //地面辅助工具

            //controls                                                                                                     控制相机
             controls = new THREE.OrbitControls(camera,renderer.domElement);

             controls.target.set(targetX,targetY,targetZ);

             camera1.lookAt(0,0,0);                     // 过渡相机  初始朝向

             // show axes in the screen
            var axes = new THREE.AxesHelper(20);
           // scene.add(axes);                                                                                                  //辅助线

            // mouseHelper

            helperSphere =  new THREE.Mesh(new THREE.SphereGeometry(.05,20,20),new THREE.MeshNormalMaterial());

            scene.add(helperSphere);                                                                                            //辅助小球

            document.addEventListener('mousemove',onDocumentMouseMove,false);

            window.addEventListener('resize',onWindowResize,false);


            var geometry = new THREE.CubeGeometry(.1,.1,.1);

          //  helper = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial() );

            helper = new Array();

            for(var i=0;i<8;i++)                                                                                        // 场景添加辅助小立方体
            {
                helper[i]=  new THREE.Mesh( geometry, new THREE.MeshNormalMaterial() );
                helper[i].position.set(rayPoint.x,rayPoint.y,rayPoint.z);
                scene.add(helper[i]);
            }

            var distanceFunction = function ( a, b ) {
                return Math.pow( a[ 0 ] - b [0 ], 2 ) +  Math.pow( a[ 1 ] - b[ 1 ], 2 ) +  Math.pow( a[ 2 ] - b[ 2 ], 2 );          //   求两点距离平方 函数
            };


            document.onmousedown = function (ev) {

                console.log("当前相机位置:"+camera1.position.x+','+camera1.position.y+','+camera1.position.z);
                console.log("当前朝向lookat"+lookatx+','+lookaty+','+lookatz);

             //   console.log("lookatx:"+lookatx);

          //      console.log("xchange:"+xchange);



            }



            document.onmouseup = function () {                                                                          // 鼠标点击事件  mouseup


                for(var i=0;i<8;i++) {

                    raycaster.set(rayPoint[i], rayDirection);                                                            //设置射线源点  与方向         射线在地面的投影


                  //  console.log("射线在地面的投影:");

                    var intersects = raycaster.intersectObjects(mesh.children, true);

                 //  console.log(intersects[0]['distance']);                                                              // distance

                    if (intersects.length > 0) {
                        helper[i].position.set(intersects[0].point.x, intersects[0].point.y, intersects[0].point.z);     //  intersects[0]  这里表示射线与房屋模型对象的第一个交点
                    //    console.log(helper[i].position.x+","+helper[i].position.y+","+helper[i].position.z);

                        positions[i*3+0] = intersects[0].point.x;
                        positions[i*3+1] = intersects[0].point.y;
                        positions[i*3+2] = intersects[0].point.z;                                                       //  将8个投影点 存放在 positions 数组里;

                    }

                }

                kdtree  = new THREE.TypedArrayUtils.Kdtree(positions,distanceFunction,3);                                 // KD-Tree

              //  console.log(positions);
               // console.log(kdtree);

                mouse.x = (event.clientX / renderer.domElement.clientWidth )*2-1;

                mouse.y = -(event.clientY / renderer.domElement.clientHeight )*2+1;

                raycaster.setFromCamera(mouse,camera1);                                                                 // camera  射线的起点     mouse 为鼠标移动所在的 二维坐标

                var intersects = raycaster.intersectObjects(mesh.children,true);                                        //这里指的是房屋模型的所有对象

                if(intersects.length>0) {

                    var  x  =  camera1.position.x;
                    var  y  =  camera1.position.y;
                    var  z  =  camera1.position.z;                                                                      //原相机坐标;

                    var  x1 =  intersects[0].point.x;
                    var  y1 =  intersects[0].point.y;
                    var  z1 =  intersects[0].point.z;                                                                   //  射线与模型第一个交点坐标;   intersects[0]  这里表示射线与房屋模型对象的第一个交点


                    var nearestPoint = kdtree.nearest([x1,y1,z1],1,20);                                                 //  最临近点

                    console.log('最近投影点：'+nearestPoint[0][0]['obj'][0]+','+nearestPoint[0][0]['obj'][1]+','+nearestPoint[0][0]['obj'][2]);             //   kdtree -- nearest



                    var xm =  nearestPoint[0][0]['obj'][0] ;
                    var ym =  nearestPoint[0][0]['obj'][1] ;
                    var zm =  nearestPoint[0][0]['obj'][2] ;

                    //console.log(ym);


                     xchange =  (xm - x);
                     zchange  =  (zm - z);

                   // console.log(xchange+'---'+zchange);

                    new TWEEN.Tween(camera1.position).to(                                                               // Tween  camera1.position
                        {
                            x:xm,
                            y:ym+0.5,
                            z:zm
                        },2000)
                        .easing(TWEEN.Easing.Quadratic.InOut)
                        .onUpdate(function () {

                            //console.log(xchange+','+zchange);
                        })
                        .start();

                    /*     交点
                    new TWEEN.Tween(camera1.position).to({
                        x:x2,
                        y:y2,
                        z:z2
                    },2000).easing(TWEEN.Easing.Quadratic.InOut).start();                                                 //  http://sole.github.io/tween.js/examples/03_graphs.html
                    */

                    //camera.lookAt(x1,y1,z1);   //  相机朝向 交点;

                   // console.log("相机朝向 向量（xyz):"+camera.getWorldDirection().x+","+camera.getWorldDirection().y+","+camera.getWorldDirection().z);


/*
                    new TWEEN.Tween(controls.target).to({
                        x:0,
                        y:0,
                        z:z1
                    },1000).easing(TWEEN.Easing.Quadratic.InOut).start();
*/
                   // console.log(camera1);

                                                                                                                         //                 loookAt
                    lookAt.x = lookatx;
                    lookAt.y = lookaty;
                    lookAt.z = lookatz;

                    //console.log("初始相机位置:"+camera1.position.x)
                  //  console.log("初始lookAt:"+lookAt.x);
                    //console.log("目标位置:"+)


                    new TWEEN.Tween(lookAt)                                                                             // Tween    lookAt
                        .to({
                        x:x1+xchange,
                        y:ym+0.8,
                        z:z1+zchange
                    },2000)
                        .easing(TWEEN.Easing.Quadratic.InOut)
                        .onUpdate(function () {
                        //console.log(lookAt);
                        //console.log("相机位置"+camera1.position.x+","+camera1.position.y+","+camera1.position.z);           //相机朝向            回调函数
                        camera1.lookAt(lookAt.x,lookAt.y,lookAt.z);
                        lookatx = lookAt.x;
                        lookaty = lookAt.y;
                        lookatz = lookAt.z;
                         //    console.log(lookaty);
                       // console.log(y1);
                       })
                        .start();

                    // console.log(lookatx);

                }

            }




            function  onWindowResize(){

               // windowHalfX = window.innerWidth/2;

               //  windowHalfY = window.innerHeight/2;

                camera.aspect = window.innerWidth / window.innerHeight;

                camera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth,window.innerHeight);

            }


            function onDocumentMouseMove (event ){

                //  [-1,1]

               // console.log("camera.posiont xyz:"+camera.position.x+","+camera.position.y+","+camera.position.z);

               // console.log("control.target xyz:"+targetX+","+targetY+","+targetZ);

                mouse.x = (event.clientX / renderer.domElement.clientWidth )*2-1;

                mouse.y = -(event.clientY / renderer.domElement.clientHeight )*2+1;

                raycaster.setFromCamera(mouse,camera);  // camera  射线的起点     mouse 为鼠标移动所在的 二维坐标

                var intersects = raycaster.intersectObjects(mesh.children,true);//这里指的是房屋模型的所有对象

                if(intersects.length>0) {

                    helperSphere.position.set(intersects[0].point.x, intersects[0].point.y, intersects[0].point.z);//  intersects[0]  这里表示射线与房屋模型对象的第一个交点

                }

                        //   console.log(rayPoint[i]);
                        // console.log(helper[i]);
             }

            /*
             console.log(mouse.x,mouse.y)

             raycaster.setFromCamera(mouse,camera);  // camera  射线的起点     mouse 为鼠标移动所在的 二维坐标

             var intersects = raycaster.intersectObjects(mesh.children,true);//这里指的是房屋模型的所有对象

               if(intersects.length>0){

                   helper.position.set(intersects[0].point.x,intersects[0].point.y,intersects[0].point.z);//  intersects[0]  这里表示射线与房屋模型对象的第一个交点


                   console.log(intersects[0]);

                   console.log("射线与对象的交叉点数 length:"+intersects.length);

                   console.log("射线源 向量：" + camera.position.x+','+camera.position.y+','+camera.position.z);

                   console.log("在世界坐标中的第一个交叉点坐标："+intersects[0].point.x+','+intersects[0].point.y+','+intersects[0].point.z );

                   console.log("射线源到第一个交点的距离:"+intersects[0].distance);

                   console.log("第一个相交面："+intersects[0].face);

                   console.log("相交面的索引："+intersects[0].faceIndex);

                   console.log("组成相交面的顶点索引:" + intersects[0].indices);


                   console.log("相交的对象:"+ intersects[0].object);



               }
                    */
            }


            function animate(){

                requestAnimationFrame(animate);
                render();

            }

            function render(){

               TWEEN.update();
               controls.update();renderer.render(scene,camera1);

            }


    </script>

</body>
</html>