<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>全景看房</title>

    <style>
        body{
            margin:0;
            overflow:hidden;
        }
    </style>

</head>
<body>

<script type="text/javascript"  src="../main/three.js"></script>
<script type="text/javascript"  src="../lib/js/loaders/OBJLoader.js"></script>
<script type="text/javascript"  src="../lib/js/loaders/MTLLoader.js"></script>
<script type="text/javascript"  src="../lib/js/loaders/DDSLoader.js"></script>
<script type="text/javascript"  src="../lib/js/loaders/ColladaLoader.js"></script>

<script type="text/javascript"  src="../lib/js/controls/OrbitControls.js"></script>

<script type="text/javascript"  src="../lib/js/Detector.js"></script>
<script type="text/javascript"  src="../lib/js/libs/stats.min.js"></script>

<script type="text/javascript"  src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script type="text/javascript"  src="../lib/js/libs/tween.min.js"></script>

<script type="text/javascript"  src="../lib/js/TypedArrayUtils.js"></script>


<script type="x-shader/x-vertex"  id="vertexshader">

    varying  vec3 pos ;

    void main(void){

        mat4 mvp = projectionMatrix * modelViewMatrix ;                                                                 // 矩阵顺序
        pos = position.xyz;
        gl_Position = mvp * vec4(pos,1.0);

    }
</script>

<script type="x-shader/x-fragment" id="fragmentshader">

    varying vec3 pos;

    uniform vec3 getPV;
    uniform vec3 offset;

    uniform samplerCube U_MainTexture;

    void main (void){

     gl_FragColor = textureCube(U_MainTexture,pos-getPV);
     //gl_FragColor = vec4(1.0,0.0,0.0,1.0);
    }


</script>

<canvas id="cv0" width="512px" height="512px" hidden="true"></canvas>
<canvas id="cv1" width="512px" height="512px" hidden="true"></canvas>
<canvas id="cv2" width="512px" height="512px" hidden="true"></canvas>
<canvas id="cv3" width="512px" height="512px" hidden="true"></canvas>
<canvas id="cv4" width="512px" height="512px" hidden="true"></canvas>
<canvas id="cv5" width="512px" height="512px" hidden="true"></canvas>

<script>


    var rayPoint = new Array();                                                                                       //  射线源

    var positions = new Float32Array(8*4);                                                                            //  8个三维坐标
    var kdtree ;                                                                                                       //   KD-Tree


    var isMove=false;
    var isMoveCount = 0;                                                                                               // 判断是否为房屋室内 相机旋转

    var isMouseDown = false;

    var isInHome =false;                                                                                               //判断相机是否在房屋内

    var isRotate = false ;                                                                                              //判断模型是否旋转

    var isSetHelp = false;                                                                                             // 是否已经初始化辅助小立方体

    var intentMouseRotate1 =0;                                                                                          //室外旋转意图      0 无意图  1有意图   -1取消意图

    var intentMouseRotate2 = 0;                                                                                         //室内旋转意图和移动意图    0 无意图  1有意图   -1取消意图

    var intentInHome = 0;                                                                                               //进入房间意图      0 无意图  1有初步意图   -1取消意图     2 有强烈意图

    var intentOutHome = 0;                                                                                              //退出房间意图      0 无意图  1有意图   -1取消意图


    var isPVRotate = 0;                                                                                                 //投影图片是否已经翻转 旋转


    var xd = 0;
    var yd = 0;
    var zd = 0;                                                                                                         //相机世界坐标系方向



    var textureCount;                                                                                                   // 平面贴图数据

    var planeGroup;                                                                                                     //平板组数据  40

    var planeGroup1;                                                                                                     // 大平板数据 60

    var planeGroup2;                                                                                                    //大平板 80


    $(function () {
        $.ajax(
            {
                type:"get",
                url:"src/VT_Model_info.json",
                dataType:"json",
                success:function(result){
                    addBox(result);
                }
            }
        );
    });
    // ajax  提取  json 数据函数   ---   jq
    function addBox(result){
        var i=0;

        $.each(result,function(index,obj)
            {
                i++;
                if(i==5) {
                    for (var j = 0; j < obj[0].length; j++) {
                        // console.log("初始:"+obj[0][j]['matrix'][3]+","+obj[0][j]['matrix'][7]+","+obj[0][j]['matrix'][11] );
                        rayPoint[j]=new THREE.Vector3(obj[0][j]['matrix'][3],obj[0][j]['matrix'][7],obj[0][j]['matrix'][11]);               //将json  4*4变换矩阵中3，7，11 坐标保存到 rayPoint数组

                        rayPoint[j].applyAxisAngle(new THREE.Vector3(1,0,0),Math.PI/2);                                                     // applyAxisAngle() 实现 绕（1，0，0）向量    旋转  pi/2

                        console.log("数据采集点:"+j+"("+obj[0][j]['matrix'][3]+","+obj[0][j]['matrix'][7]+","+obj[0][j]['matrix'][11] +")");

                        // console.log("变换后:"+rayPoint[j].x+","+rayPoint[j].y+","+rayPoint[j].z);
                        /*           实现了相机自传            未实现 相机绕x轴转
                        //console.log(rayPoint[j]+"----"+j);
                        var cube = new THREE.PerspectiveCamera();
                        cube.position.set( rayPoint[j].x,rayPoint[j].y,rayPoint[j].z );
                        console.log(cube.position);
                        cube.applyAxisAngle(new THREE.Vector3(1,0,0),Math.PI/2);
                        console.log("旋转后："+cube.position.x+","+cube.position.y+","+cube.position.z);
                            */

                    }
                }
            }
        );
    }



    var container;
    var camera,scene,renderer;
    var helper;
    var helperSphere;
    var mesh;
    var controls;

    var uniforms;

    var mouse = new THREE.Vector2();
    var raycaster = new THREE.Raycaster()

    // var   rayOrigin = new THREE.Vector3(0,0,0);    //  射线源点
    var   rayDirection = new THREE.Vector3(0,-1,0);   // 射线方向              xz面法向量

    init();
    animate();

    function init(){

        container = document.createElement('div');
        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,0.01,2000);                       //相机基本属性      近焦过大可能会影响视觉体验

        var initX=1.916,initY=6.143,initZ=17.256;

        camera.position.set(initX,initY,initZ);                                                                         //  相机初始位置

        console.log("透视相机初始位置"+initX+','+initY+','+initZ)

        console.log("相机初始朝向0,0,0");

        scene = new THREE.Scene();

        var ambientLight = new THREE.AmbientLight(0xffffff,1);

        console.log("环境光RGB：0xcccccc, 强度:0.4");

        scene.add(ambientLight);

        var pointLight = new THREE.PointLight(0xffffff,0.8);

       // console.log("点光RGB:0xfffffff,强度0.8");
      //  camera.add(pointLight);

        scene.add(camera);



        var onProgress = function (xhr){
            if(xhr.lengthComputable){
                var percentComplete = xhr.loaded/xhr.total*100;
                console.log( Math.round(percentComplete,2)+'% downloaded');
            }
        };

        var onError = function(xhr){ };

        THREE.Loader.Handlers.add(/\.dds$/i,new THREE.DDSLoader());

        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('src/floor3/');
        mtlLoader.load('VT_Model.mtl',function (materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('src/floor3/');

            objLoader.load('VT_Model.obj', function (object) {                                                          //模型加载

                mesh = object;  // 获取obj 对象 并保存
                mesh.rotation.x = Math.PI / 2;                                                                           //模型绕x轴旋转  pi/2

                /*  object.children[0].geometry.computeBoundingBox()
                offset = object.children[0].geometry.boundingBox.getCenter();
                object.children[0].geometry.center();*/
                console.log(mesh);

                for(var i=0;i<mesh['children'][0]['material'].length;i++)
                {
                    //console.log(mesh['children'][0]['material'][i]['depthTest']);
                    mesh['children'][0]['material'][i]['transparent'] =true;
                    mesh['children'][0]['material'][i]['opacity'] = 1;

                }

                scene.add(object);

                var geometry = new THREE.CubeGeometry(.1,.1,.1);

                //  helper = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial() );

                helper = new Array();
               // THREE.NoBlending;
                for(var i=0;i<8;i++)                                                                                   // 场景添加辅助小立方体
                {
                    helper[i]=  new THREE.Mesh( geometry, new THREE.MeshNormalMaterial() );
                    helper[i].position.set(rayPoint.x,rayPoint.y,rayPoint.z);
                    helper[i]['material']['depthTest'] = true;                                                       //   !! 深度测试生效的前提之一是  transparent = true; !!
                    helper[i]['material']['transparent'] = true;

                    scene.add(helper[i]);
                }
            }, onProgress, onError);

        });

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth,window.innerHeight);

        renderer.sortObjects = false;

         container.appendChild(renderer.domElement);

        //helper

        var gridHelper = new THREE.GridHelper(10,20);
        scene.add(gridHelper);                                                                                          //地面辅助工具

        //controls                                                                                                       // 轨道控制器            controls
        controls = new THREE.OrbitControls(camera,renderer.domElement);

        controls.enableDamping = true;                                                                                  // 惯性

        controls.rotateSpeed = 0.3;

         //controls.dampingFactor = 1.5;                                                                                 // 相机旋转速度
        console.log('dampingFactor:'+controls.dampingFactor);


        // show axes in the screen
        var axes = new THREE.AxesHelper(20);
         scene.add(axes);                                                                                                  //辅助坐标系

        // mouseHelper

        helperSphere =  new THREE.Mesh(new THREE.SphereGeometry(.05,20,20),new THREE.MeshNormalMaterial());

        scene.add(helperSphere);                                                                                            //辅助小球




/*
        //cubemap                                                                                                          // Cube  立方体全景
        var path = "textures/";
        var format = '.jpg';
        var urls = [
            path + 'posx' + format,
            path + 'negx' + format,
            path + 'posy' + format,
            path + 'negy' + format,
            path + 'posz' + format,
            path + 'negz' + format
        ];

        var reflectionCube = new THREE.CubeTextureLoader().load( urls );
        reflectionCube.format = THREE.RGBFormat;

        var refractionCube = new THREE.CubeTextureLoader().load( urls );
        refractionCube.mapping = THREE.CubeRefractionMapping;
        refractionCube.format = THREE.RGBFormat;

*/
       // scene = new THREE.Scene();

       // scene.background = reflectionCube;

        // 平板组 -- 立方体全景

    /*    var url = './src/2k/';
        textureCount = 1;

        planeGroup = new THREE.Group();                                                                                 //平面组
        var planeGeo = new THREE.PlaneBufferGeometry(40.01,40.01);

        //top
        var planeTop = new THREE.Mesh(planeGeo,new THREE.MeshPhongMaterial({map:THREE.ImageUtils.loadTexture(url+'Pannorama_00'+textureCount+'_1_high.jpg')}));             // ！！material 如果有颜色会与环境光产生影响，   无论有无颜色都会与点光源产生影响
        planeTop.position.y = 20;
        planeTop.rotateX(Math.PI / 2 );
        planeTop.rotation.z = -Math.PI/2;
        planeGroup.add(planeTop);

        //front
        var planeFront = new THREE.Mesh(planeGeo, new THREE.MeshPhongMaterial({map:THREE.ImageUtils.loadTexture(url+'Pannorama_00'+textureCount+'_2_high.jpg')}));
        planeFront.position.z = 20;
        planeFront.position.y = 0;
        planeFront.rotateY(Math.PI);
        planeGroup.add(planeFront);

        // left
        var planeLeft = new THREE.Mesh(planeGeo,new THREE.MeshPhongMaterial({map:THREE.ImageUtils.loadTexture(url+'Pannorama_00'+textureCount+'_3_high.jpg')}) );
        planeLeft.position.x = -20;
        planeLeft.position.y = 0;
        planeLeft.rotateY(Math.PI/2);
        planeGroup.add(planeLeft);

        //behind
        var planeBehind = new THREE.Mesh(planeGeo,new THREE.MeshPhongMaterial({map:THREE.ImageUtils.loadTexture(url+'Pannorama_00'+textureCount+'_4_high.jpg')}));
        planeBehind.position.z = -20;
        planeBehind.position.y = 0;
        //planeBehind.rotateZ(-Math.PI/2);
        planeGroup.add(planeBehind);

        //right
        var planeRight = new THREE.Mesh(planeGeo,new THREE.MeshPhongMaterial({map:THREE.ImageUtils.loadTexture(url+'Pannorama_00'+textureCount+'_5_high.jpg')}));
        planeRight.position.x = 20 ;
        planeRight.position.y = 0;
        planeRight.rotateY(- Math.PI/2);
        planeGroup.add(planeRight);


        //bottom
        var planeBottom = new THREE.Mesh(planeGeo,new THREE.MeshPhongMaterial({map:THREE.ImageUtils.loadTexture(url+'Pannorama_00'+textureCount+'_6_high.jpg')}));
        planeBottom.position.y = -20;
        planeBottom.rotateX(-Math.PI/2);
        planeBottom.rotation.z = Math.PI;
        planeGroup.add(planeBottom);

      //  scene.add(planeGroup);                                                                                  //加载40立方体全景



        //console.log(planeGroup['children']);
        planeGroup1 = new THREE.Group();                                                                                 //平面组  60
        var planeGeo = new THREE.PlaneBufferGeometry(60.01,60.01);

        //top
        var planeTop = new THREE.Mesh(planeGeo,new THREE.MeshPhongMaterial({map:THREE.ImageUtils.loadTexture(url+'Pannorama_00'+textureCount+'_1_high.jpg')}));             // ！！material 如果有颜色会与环境光产生影响，   无论有无颜色都会与点光源产生影响
        planeTop.position.y = 30;
        planeTop.rotateX(Math.PI / 2 );
        planeTop.rotation.z = -Math.PI/2;
        planeGroup1.add(planeTop);

        //front
        var planeFront = new THREE.Mesh(planeGeo, new THREE.MeshPhongMaterial({map:THREE.ImageUtils.loadTexture(url+'Pannorama_00'+textureCount+'_2_high.jpg')}));
        planeFront.position.z = 30;
        planeFront.position.y = 0;
        planeFront.rotateY(Math.PI);
        planeGroup1.add(planeFront);

        // left
        var planeLeft = new THREE.Mesh(planeGeo,new THREE.MeshPhongMaterial({map:THREE.ImageUtils.loadTexture(url+'Pannorama_00'+textureCount+'_3_high.jpg')}) );
        planeLeft.position.x = -30;
        planeLeft.position.y = 0;
        planeLeft.rotateY(Math.PI/2);
        planeGroup1.add(planeLeft);

        //behind
        var planeBehind = new THREE.Mesh(planeGeo,new THREE.MeshPhongMaterial({map:THREE.ImageUtils.loadTexture(url+'Pannorama_00'+textureCount+'_4_high.jpg')}));
        planeBehind.position.z = -30;
        planeBehind.position.y = 0;
        //planeBehind.rotateZ(-Math.PI/2);
        planeGroup1.add(planeBehind);

        //right
        var planeRight = new THREE.Mesh(planeGeo,new THREE.MeshPhongMaterial({map:THREE.ImageUtils.loadTexture(url+'Pannorama_00'+textureCount+'_5_high.jpg')}));
        planeRight.position.x = 30 ;
        planeRight.position.y = 0;
        planeRight.rotateY(- Math.PI/2);
        planeGroup1.add(planeRight);


        //bottom
        var planeBottom = new THREE.Mesh(planeGeo,new THREE.MeshPhongMaterial({map:THREE.ImageUtils.loadTexture(url+'Pannorama_00'+textureCount+'_6_high.jpg')}));
        planeBottom.position.y = -30;
        planeBottom.rotateX(-Math.PI/2);
        planeBottom.rotation.z = Math.PI;
        planeGroup1.add(planeBottom);

      //  scene.add(planeGroup1);                                                                                  //加载60立方体全景

        planeGroup2 = new THREE.Group();                                                                                 //平面组  80
        var planeGeo = new THREE.PlaneBufferGeometry(80.01,80.01);

        //top
        var planeTop = new THREE.Mesh(planeGeo,new THREE.MeshPhongMaterial({map:THREE.ImageUtils.loadTexture(url+'Pannorama_00'+textureCount+'_1_high.jpg')}));             // ！！material 如果有颜色会与环境光产生影响，   无论有无颜色都会与点光源产生影响
        planeTop.position.y = 40;
        planeTop.rotateX(Math.PI / 2 );
        planeTop.rotation.z = -Math.PI/2;
        planeGroup2.add(planeTop);

        //front
        var planeFront = new THREE.Mesh(planeGeo, new THREE.MeshPhongMaterial({map:THREE.ImageUtils.loadTexture(url+'Pannorama_00'+textureCount+'_2_high.jpg')}));
        planeFront.position.z = 40;
        planeFront.position.y = 0;
        planeFront.rotateY(Math.PI);
        planeGroup2.add(planeFront);

        // left
        var planeLeft = new THREE.Mesh(planeGeo,new THREE.MeshPhongMaterial({map:THREE.ImageUtils.loadTexture(url+'Pannorama_00'+textureCount+'_3_high.jpg')}) );
        planeLeft.position.x = -40;
        planeLeft.position.y = 0;
        planeLeft.rotateY(Math.PI/2);
        planeGroup2.add(planeLeft);

        //behind
        var planeBehind = new THREE.Mesh(planeGeo,new THREE.MeshPhongMaterial({map:THREE.ImageUtils.loadTexture(url+'Pannorama_00'+textureCount+'_4_high.jpg')}));
        planeBehind.position.z = -40;
        planeBehind.position.y = 0;
        //planeBehind.rotateZ(-Math.PI/2);
        planeGroup2.add(planeBehind);

        //right
        var planeRight = new THREE.Mesh(planeGeo,new THREE.MeshPhongMaterial({map:THREE.ImageUtils.loadTexture(url+'Pannorama_00'+textureCount+'_5_high.jpg')}));
        planeRight.position.x = 40 ;
        planeRight.position.y = 0;
        planeRight.rotateY(- Math.PI/2);
        planeGroup2.add(planeRight);


        //bottom
        var planeBottom = new THREE.Mesh(planeGeo,new THREE.MeshPhongMaterial({map:THREE.ImageUtils.loadTexture(url+'Pannorama_00'+textureCount+'_6_high.jpg')}));
        planeBottom.position.y = -40;
        planeBottom.rotateX(-Math.PI/2);
        planeBottom.rotation.z = Math.PI;
        planeGroup2.add(planeBottom);

      //  scene.add(planeGroup2);                                                                                  //加载60立方体全景

*/



        //     console.log(scene);



      /*  scene.add(planeGroup);

        console.log("立方体加载");*/


        document.addEventListener('mousemove',onDocumentMouseMove,false);

        window.addEventListener('resize',onWindowResize,false);


        var geometry = new THREE.CubeGeometry(.1,.1,.1);

        //  helper = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial() );

        helper = new Array();

        for(var i=0;i<rayPoint.length;i++)                                                                                           // 场景添加辅助小立方体
        {
            helper[i]=  new THREE.Mesh( geometry, new THREE.MeshNormalMaterial() );
            helper[i].position.set(rayPoint.x,rayPoint.y,rayPoint.z);
            helper[i]['material']['depthTest'] = false;
           // console.log(helper[i]['material']);
            scene.add(helper[i]);
        }

        var distanceFunction = function ( a, b ) {
            return Math.pow( a[ 0 ] - b [0 ], 2 ) +  Math.pow( a[ 1 ] - b[ 1 ], 2 ) +  Math.pow( a[ 2 ] - b[ 2 ], 2 );  //   求两点距离平方 函数
        };


/*        var showDomeFunction = function(){                                                                            //显示模型


        }

       var hideDomeFunction =  function () {                                                                           //隐藏模型



        }*/




        document.onmousedown = function () {

            isMove =false;
            isMoveCount = 0;
            isMouseDown = true;



          if(!isInHome) {
              if (intentInHome == 0) {
                  intentMouseRotate1 = 1;
                  console.log("有强旋转模型意图");
              }
              if (intentInHome == 1) {
                  console.log("有弱旋转模型或者强烈进入房间意图");
                  intentMouseRotate1 = 1;
                  intentInHome = 2;
              }
          }
           // console.log("按下鼠标");


           /*                   隐藏  obj                       ---  obj-material-opacity(0,1)-->0          !!!<-->! transparent == true;
            for(var i=0;i<mesh['children'][0]['material'].length;i++)
            {
                console.log(mesh['children'][0]['material'][i]['opacity']);
                mesh['children'][0]['material'][i]['transparent'] =true;
                mesh['children'][0]['material'][i]['opacity'] = 0;

            }

            */
        }

        document.onmouseup = function () {                                                                             // 鼠标点击事件  mouseup

            //controls.update();
            // isMove =false;

            intentMouseRotate1 = -1;                                                                                    //取消室外旋转意图
            isRotate = false;                                                                                          // 取消旋转状态

            isMouseDown = false;
            // console.log("松开鼠标按键");

            //  console.log(controls.target);

            if (!isSetHelp) {                                                                                           //是否已经设置辅助小块

                isSetHelp = true;
                console.log("辅助小立方体，KD树生成完毕!");
                console.log(scene);

/*
                var path = "./src/512/";
                var format = '.jpg';
                var urls = [
                    path + 'Pannorama_001_3_low' + format, path + 'Pannorama_001_5_low' + format,
                    path + 'Pannorama_001_1_low' + format, path + 'Pannorama_001_6_low' + format,
                    path + 'Pannorama_001_2_low' + format, path + 'Pannorama_001_4_low' + format
                ];
*/

             /*   console.log("mesh:");
                console.log(mesh);*/

                for (var i = 0; i < 8; i++) {

                    raycaster.set(rayPoint[i], rayDirection);                                                           //设置射线源点  与方向         射线在地面的投影
                    //  console.log("射线在地面的投影:");

                    var intersects = raycaster.intersectObjects(mesh.children, true);
                    //  console.log(intersects[0]['distance']);                                                          // distance
                    if (intersects.length > 0) {
                        helper[i].position.set(intersects[0].point.x, intersects[0].point.y, intersects[0].point.z);    // intersects[0]  这里表示射线与房屋模型对象的第一个交点
                        //    console.log(helper[i].position.x+","+helper[i].position.y+","+helper[i].position.z);

                        positions[i * 4 + 0] = intersects[0].point.x;
                        positions[i * 4 + 1] = intersects[0].point.y;
                        positions[i * 4 + 2] = intersects[0].point.z;                                                     //将8个投影点 存放在 positions 数组里;
                        positions[i * 4 + 3] = i;                                                                         //下标保存在第四个位置上

                    }

                }

                kdtree = new THREE.TypedArrayUtils.Kdtree(positions, distanceFunction, 4);                               //KD-Tree 算法

            }                                                                                                            //KD树与辅助小立方体生成


            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;

            mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;


            if (intentInHome == 2  || isInHome) {                                                                       //在房间内且

                raycaster.setFromCamera(mouse, camera);                                                                 // camera  射线的起点     mouse 为鼠标移动所在的 二维坐标
                var intersects = raycaster.intersectObjects(mesh.children, true);                                      //这里指的是房屋模型的所有对象
                if (intersects.length > 0) {

                    var x = camera.position.x;
                    var y = camera.position.y;
                    var z = camera.position.z;                                                                          //原相机坐标;

                    var x1 = intersects[0].point.x;
                    var y1 = intersects[0].point.y;
                    var z1 = intersects[0].point.z;                                                                     //  射线与模型第一个交点坐标;   intersects[0]  这里表示射线与房屋模型对象的第一个交点

                    var nearestPoint = kdtree.nearest([x1, y1, z1], 1, 20);                                             //  最临近点设置

                    var xm = nearestPoint[0][0]['obj'][0];
                    var ym = nearestPoint[0][0]['obj'][1];
                    var zm = nearestPoint[0][0]['obj'][2];
                    var nearestCount = nearestPoint[0][0]['obj'][3] +1;

                    xd = camera.getWorldDirection().x;
                    yd = camera.getWorldDirection().y;
                    zd = camera.getWorldDirection().z;                                                                   // 当前相机方向






                    if (controls.getPolarAngle() - 0.0001 > 0 && isMoveCount < 2 )                                       //  过滤垂直俯视,转向移动
                    {

                            if(isInHome == false)                                                                       //是否从室外点击地面
                            {
                                new TWEEN.Tween(camera.position).to(                                                     //相机平移到数据采集点
                                    {
                                        x: xm,
                                        y: 0,
                                        z: zm
                                    }, 1500)
                                    .easing(TWEEN.Easing.Quadratic.InOut)
                                    .onUpdate (function(){
                                        console.log("正在从室外进入房间");
                                    })
                                    .start();                                                                               //Tween  camera.position

                                new TWEEN.Tween(controls.target).to({                                                       //  controls.target 抬升效果

                                    x: xm + xd/ 32,
                                    y: 0,
                                    z: zm +zd/ 32

                                }, 1500)
                                    .easing(TWEEN.Easing.Quadratic.InOut)
                         /*           .onComplete (function () {

                                        for(var i=0;i<mesh['children'][0]['material'].length;i++)
                                        {
                                            console.log(mesh['children'][0]['material'][i]['opacity']);
                                            mesh['children'][0]['material'][i]['transparent'] =true;
                                            mesh['children'][0]['material'][i]['opacity'] = 0;

                                        }
                                    })*/
                                    .start();

                                var textureCube = new THREE.CubeTexture();
                                var canvasAry = new Array();
                                var countPV = 0;
                                for(var i= 0 ;i<6;i++)                                                                                           //js  for   闭包处理
                                {
                                    (function(i )
                                    {
                                        canvasAry[i] = document.getElementById("cv"+i);
                                        var  ctx1 = canvasAry[i].getContext("2d");
                                        var img = new Image();
                                        var j = i+1;
                                        img.onload = function( ) {


                                            if (!isPVRotate) {
                                                if (0 == i)                                                                                                  //  表示第0张图 加载完             先旋转  后翻转
                                                {
                                                    var xpos = canvasAry[0].width / 2;
                                                    var ypos = canvasAry[0].height / 2;
                                                    ctx1.translate(xpos, ypos);
                                                    ctx1.rotate(-Math.PI / 2);
                                                    ctx1.translate(-xpos, -ypos);
                                                    ctx1.drawImage(img, xpos - img.width / 2, ypos - img.height / 2);

                                                }

                                                if (3 == i) {
                                                    var xpos = canvasAry[0].width / 2;
                                                    var ypos = canvasAry[0].height / 2;
                                                    ctx1.translate(xpos, ypos);
                                                    ctx1.rotate(Math.PI);
                                                    ctx1.translate(-xpos, -ypos);
                                                    ctx1.drawImage(img, xpos - img.width / 2, ypos - img.height / 2);

                                                }

                                                if (2 == i)                                                                                                  //  表示第2张图 加载完             先旋转  后翻转
                                                {
                                                    var xpos = canvasAry[0].width / 2;
                                                    var ypos = canvasAry[0].height / 2;
                                                    ctx1.translate(xpos, ypos);
                                                    ctx1.rotate(-Math.PI / 2);
                                                    ctx1.translate(-xpos, -ypos);
                                                    ctx1.drawImage(img, xpos - img.width / 2, ypos - img.height / 2);

                                                }
                                                if (4 == i)                                                                                                  //  表示第4张图 加载完             先旋转  后翻转
                                                {
                                                    var xpos = canvasAry[0].width / 2;
                                                    var ypos = canvasAry[0].height / 2;
                                                    ctx1.translate(xpos, ypos);
                                                    ctx1.rotate(Math.PI / 2);
                                                    ctx1.translate(-xpos, -ypos);
                                                    ctx1.drawImage(img, xpos - img.width / 2, ypos - img.height / 2);

                                                }
                                                if (1 == i)                                                                                                  //  表示第1张图 加载完             先旋转  后翻转
                                                {
                                                    var xpos = canvasAry[0].width / 2;
                                                    var ypos = canvasAry[0].height / 2;
                                                    ctx1.translate(xpos, ypos);
                                                    //  ctx1.rotate( -Math.PI/2);
                                                    ctx1.translate(-xpos, -ypos);
                                                    ctx1.drawImage(img, xpos - img.width / 2, ypos - img.height / 2);

                                                }
                                                if (5 == i)                                                                                                  //  表示第5张图 加载完             先旋转  后翻转
                                                {
                                                    var xpos = canvasAry[0].width / 2;
                                                    var ypos = canvasAry[0].height / 2;
                                                    ctx1.translate(xpos, ypos);
                                                    //  ctx1.rotate( -Math.PI/2);
                                                    ctx1.translate(-xpos, -ypos);
                                                    ctx1.drawImage(img, xpos - img.width / 2, ypos - img.height / 2);

                                                }


                                                //只翻转一次
                                                ctx1.transform(-1, 0, 0, 1, 512, 0);
                                                console.log("翻转旋转 ");

                                            }
                                            ctx1.drawImage(img, 0, 0,img.width,img.height);
                                           // console.log(i);
                                            countPV++;
                                            if(countPV>5)
                                            {
                                                textureCube.images[0] = canvasAry[4];
                                                textureCube.images[1] = canvasAry[2];
                                                textureCube.images[2] = canvasAry[1];                                                                 //top
                                                textureCube.images[3] = canvasAry[3];                                                                 //bo
                                                textureCube.images[4] = canvasAry[5];                                                                 //b
                                                textureCube.images[5] = canvasAry[0];                                                                 //front
                                                textureCube.needsUpdate=true;
                                                isPVRotate = 1;                                                                        //  只翻转一次
                                                console.log(textureCube);
                                            }
                                        }
                                        img.src = "../VT-Test/src/512/Pannorama_00"+nearestCount+"_"+j+"_low.jpg";                  // 临近点 所绑定的全景图组
                                        /*  console.log(canvasAry[i]);
                                          console.log(img);*/
                                    })(i);
                                }


                                var mainTexture;
                                mainTexture = textureCube;

                               mesh.updateMatrixWorld();

                                console.log("第"+nearestCount+"个全景图");
                                uniforms = {
                                    U_MainTexture:{ value : mainTexture },
                                    getPV:{value:new THREE.Vector3(rayPoint[nearestCount-1].x,rayPoint[nearestCount-1].y,rayPoint[nearestCount-1].z).applyAxisAngle(new THREE.Vector3(1,0,0),-Math.PI/2)}

                                };

                                var shaderMaterial = new THREE.ShaderMaterial(
                                    {
                                        //side: THREE.BackSide,
                                        // side:THREE.DoubleSide,
                                        uniforms: uniforms,
                                        vertexShader: document.getElementById('vertexshader').textContent,
                                        fragmentShader: document.getElementById(('fragmentshader')).textContent,
                                        depthTest: true,                                                                                // depthTest  默认为true 若手动设置为false  投影到模型会影响模型的depthTest;
                                        transparent: true
                                    });

                                mesh.children[0].material = shaderMaterial;


                                console.log("优雅的进入房间");
                              // console.log(scene);


                                controls.rotateSpeed = -0.3;                                                                          //  旋转速度

                                                        //*              隐藏  obj                       ---  obj-material-opacity(0,1)-->0          !!!<-->! transparent == true;
                            /*   for(var i=0;i<mesh['children'][0]['material'].length;i++)
                               {
                                   console.log(mesh['children'][0]['material'][i]['opacity']);
                                   mesh['children'][0]['material'][i]['transparent'] =true;
                                   mesh['children'][0]['material'][i]['opacity'] = 0;

                               }*/

                      /*      textureCount = nearestCount+1;

                            console.log("count"+textureCount);
                            // planeGroup[]
                                for(var i =0;i<planeGroup['children'].length;i++)
                                {
                                    var j = i+1;
                                    planeGroup['children'][i]['material']['map'] = THREE.ImageUtils.loadTexture(url + 'Pannorama_00' + textureCount + '_'+j+'_high.jpg');
                                }*/

                                isInHome = true;                                                                    //表示相机已经进入房间
                            }

                            else {                                                                                  //在室内移动

                                var textureCube = new THREE.CubeTexture();
                                var canvasAry = new Array();
                                var countPV = 0;
                                for(var i= 0 ;i<6;i++)                                                                                           //js  for   闭包处理
                                {
                                    (function(i )
                                    {
                                        canvasAry[i] = document.getElementById("cv"+i);
                                        var  ctx1 = canvasAry[i].getContext("2d");
                                        var img = new Image();
                                        var j = i+1;
                                        img.onload = function( ) {


                                            if (!isPVRotate) {
                                                if (0 == i)                                                                                                  //  表示第0张图 加载完             先旋转  后翻转
                                                {
                                                    var xpos = canvasAry[0].width / 2;
                                                    var ypos = canvasAry[0].height / 2;
                                                    ctx1.translate(xpos, ypos);
                                                    ctx1.rotate(-Math.PI / 2);
                                                    ctx1.translate(-xpos, -ypos);
                                                    ctx1.drawImage(img, xpos - img.width / 2, ypos - img.height / 2);

                                                }

                                                if (3 == i) {
                                                    var xpos = canvasAry[0].width / 2;
                                                    var ypos = canvasAry[0].height / 2;
                                                    ctx1.translate(xpos, ypos);
                                                    ctx1.rotate(Math.PI);
                                                    ctx1.translate(-xpos, -ypos);
                                                    ctx1.drawImage(img, xpos - img.width / 2, ypos - img.height / 2);

                                                }

                                                if (2 == i)                                                                                                  //  表示第2张图 加载完             先旋转  后翻转
                                                {
                                                    var xpos = canvasAry[0].width / 2;
                                                    var ypos = canvasAry[0].height / 2;
                                                    ctx1.translate(xpos, ypos);
                                                    ctx1.rotate(-Math.PI / 2);
                                                    ctx1.translate(-xpos, -ypos);
                                                    ctx1.drawImage(img, xpos - img.width / 2, ypos - img.height / 2);

                                                }
                                                if (4 == i)                                                                                                  //  表示第4张图 加载完             先旋转  后翻转
                                                {
                                                    var xpos = canvasAry[0].width / 2;
                                                    var ypos = canvasAry[0].height / 2;
                                                    ctx1.translate(xpos, ypos);
                                                    ctx1.rotate(Math.PI / 2);
                                                    ctx1.translate(-xpos, -ypos);
                                                    ctx1.drawImage(img, xpos - img.width / 2, ypos - img.height / 2);

                                                }
                                                if (1 == i)                                                                                                  //  表示第1张图 加载完             先旋转  后翻转
                                                {
                                                    var xpos = canvasAry[0].width / 2;
                                                    var ypos = canvasAry[0].height / 2;
                                                    ctx1.translate(xpos, ypos);
                                                    //  ctx1.rotate( -Math.PI/2);
                                                    ctx1.translate(-xpos, -ypos);
                                                    ctx1.drawImage(img, xpos - img.width / 2, ypos - img.height / 2);

                                                }
                                                if (5 == i)                                                                                                  //  表示第5张图 加载完             先旋转  后翻转
                                                {
                                                    var xpos = canvasAry[0].width / 2;
                                                    var ypos = canvasAry[0].height / 2;
                                                    ctx1.translate(xpos, ypos);
                                                    //  ctx1.rotate( -Math.PI/2);
                                                    ctx1.translate(-xpos, -ypos);
                                                    ctx1.drawImage(img, xpos - img.width / 2, ypos - img.height / 2);

                                                }


                                                //只翻转一次
                                                ctx1.transform(-1, 0, 0, 1, 512, 0);
                                                console.log("翻转旋转 ");

                                            }
                                            ctx1.drawImage(img, 0, 0,img.width,img.height);

                                            console.log(i);
                                            //console.log(textureCube);
                                            //console.log(canvasAry[count]);
                                            countPV++;
                                            if(countPV>5)
                                            {
                                                textureCube.images[0] = canvasAry[4];
                                                textureCube.images[1] = canvasAry[2];
                                                textureCube.images[2] = canvasAry[1];                                                                 //top
                                                textureCube.images[3] = canvasAry[3];                                                                 //bo
                                                textureCube.images[4] = canvasAry[5];                                                                 //b
                                                textureCube.images[5] = canvasAry[0];                                                                 //front
                                                textureCube.needsUpdate=true;
                                                isPVRotate = 1;                                                                        //  只翻转一次
                                                console.log(textureCube);
                                            }
                                        }

                                        img.src = "../VT-Test/src/512/Pannorama_00"+nearestCount+"_"+j+"_low.jpg";
                                        /*  console.log(canvasAry[i]);
                                          console.log(img);*/
                                    })(i);
                                }


                                var mainTexture;
                                mainTexture = textureCube;

                                console.log(nearestCount);
                                uniforms = {
                                    U_MainTexture:{ value : mainTexture },
                                    getPV:{value:new THREE.Vector3(rayPoint[nearestCount-1].x,rayPoint[nearestCount-1].y,rayPoint[nearestCount-1].z).applyAxisAngle(new THREE.Vector3(1,0,0),-Math.PI/2)}
                                };

                                var shaderMaterial = new THREE.ShaderMaterial(
                                    {
                                        //side: THREE.BackSide,
                                        // side:THREE.DoubleSide,
                                        uniforms: uniforms,
                                        vertexShader: document.getElementById('vertexshader').textContent,
                                        fragmentShader: document.getElementById(('fragmentshader')).textContent,
                                        depthTest: true,                                                                                // depthTest  默认为true 若手动设置为false  投影到模型会影响模型的depthTest;
                                        transparent: true
                                    });

                                mesh.children[0].material = shaderMaterial;



                                /*                      textureCount = nearestCount+1;
                                                      //console.log("第"+textureCount+"个场景 全景低清图加载完毕");
                                                      // planeGroup[]
                                                      for(var i =0;i<planeGroup['children'].length;i++)                                         //临近点全景加载
                                                      {
                                                          var j = i + 1;
                                                          // console.log("替换前图片路径");
                                                          // console.log(planeGroup['children'][i]['material']['map']['image']['currentSrc']);
                                                        //  planeGroup['children'][i]['material']['transparent']=false;

                                                          planeGroup['children'][i]['material']['map'] = THREE.ImageUtils.loadTexture('./src/512/' + 'Pannorama_00' + textureCount + '_' + j + '_low.jpg');                   //邻近点位40立方体加载低清图
                                                        /!*  console.log("替换后图片路径");
                                                          console.log(planeGroup['children'][i]['material']['map']);
                      *!/
                                                          planeGroup1['children'][i]['material']['map'] = THREE.ImageUtils.loadTexture('./src/1k/' + 'Pannorama_00' + textureCount + '_' + j + '_mob.jpg');                   //临近点位60立方体加载中清图

                                                      }
                                                       */
                                                          new TWEEN.Tween(camera.position).to(
                                                          {
                                                              x: xm,
                                                              y: 0,
                                                              z: zm
                                                          },1500)
                                                          .easing(TWEEN.Easing.Quadratic.InOut)
                                                              .onUpdate(function(progress )
                                                              {
                                                                  console.log(progress);

                                                              })
                                                          .onStart(function () {

                                                          })
                                                          .start();                                                                               //Tween  camera.position


                                /*
                               for(var i =0;i<planeGroup['children'].length;i++)                                         //临近点全景加载
                                {
                                    planeGroup['children'][i]['material']['transparent']=true;
                                    new TWEEN.Tween(planeGroup['children'][i]['material'])                                      // 40 立方体全景 渐渐透明;
                                        .to(
                                            {
                                                opacity: 0
                                            }, 1500)
                                        .easing(TWEEN.Easing.Quadratic.InOut)
                                        .start();

                                    planeGroup1['children'][i]['material']['transparent']=true;

                                    planeGroup1['children'][i]['material']['opacity']=0;
                                    new TWEEN.Tween(planeGroup1['children'][i]['material'])                                      // 60 立方体全景 渐渐显示;
                                        .to(
                                            {
                                                opacity: 1
                                            }, 1500)
                                        .easing(TWEEN.Easing.Quadratic.InOut)
                                        .start();

                                }*/



                                new TWEEN.Tween(controls.target).to({

                                    x: xm+ xd/32 ,
                                    y: 0 + yd/32 ,
                                    z: zm +zd/32

                                },1500)
                                    .easing(TWEEN.Easing.Quadratic.InOut)
                                   /* .onComplete(function () {*/
                                      /*  for(var i=0;i<mesh['children'][0]['material'].length;i++) {

                                            mesh['children'][0]['material'][i]['opacity'] = 0;
                                        /!*    new TWEEN.Tween(mesh['children'][0]['material'][i]).to({
                                                opacity:0
                                            },500)                                                                        //100毫秒后隐藏模型
                                                .easing(TWEEN.Easing.Quadratic.InOut)
                                                .start();
                                        *!/
                                        }

                                        for(var i =0;i<planeGroup['children'].length;i++)                                      //全景切换
                                        {

                                            planeGroup['children'][i]['material']['transparent'] = true;
                                            planeGroup['children'][i]['material']['opacity'] = 0;                               //40全景隐藏
                                            console.log("隐藏 40 ")
                                        }


                                    })*/
                                    .start();



                      /*          for(var i=0;i<mesh['children'][0]['material'].length;i++)
                                {
                                    mesh['children'][0]['material'][i]['opacity'] = 1;                                  //瞬间显示模型

                                }



                                for(var i =0;i<planeGroup['children'].length;i++)                                      //全景切换
                                {
                                    planeGroup['children'][i]['material']['transparent'] = true;
                                    planeGroup['children'][i]['material']['opacity'] = 1;                               //40全景显示
                                }
*/


                              //  console.log("!!!!!!相机朝向 向量（xyz):" + camera.getWorldDirection().x + "," + camera.getWorldDirection().y + "," + camera.getWorldDirection().z);

          /*                      textureCount = nearestCount+1;

                                console.log("count"+textureCount);
                                // planeGroup[]
                                for(var i =0;i<planeGroup['children'].length;i++)                                         //全景切换
                                {
                                    var j = i+1;
                                    planeGroup['children'][i]['material']['map'] = THREE.ImageUtils.loadTexture(url + 'Pannorama_00' + textureCount + '_'+j+'_high.jpg');
                                }

                                for(var i=0;i<mesh['children'][0]['material'].length;i++)
                                {
                                    mesh['children'][0]['material'][i]['opacity'] = 1;                                      //瞬间显示模型
                                    //  console.log( mesh['children'][0]['material'][i].opacity);
                                }


                                for(var i=0;i<mesh['children'][0]['material'].length;i++)
                                {
                                   new TWEEN.Tween(mesh['children'][0]['material'][i]).to({                                 // 模型显示后透明渐变

                                       opacity:0
                                   },3000)
                                       .easing(TWEEN.Easing.Quadratic.InOut)
                                       .start();
                                }*/

                            }

                        }

                    if (isInHome == true &&x1 > -0.9 && x1 < -0.4 && y1 > -0.6 && y1 < 0 && z1 > -2 && z1 < 1.1)         //在屋内点击电视区域  退出房间
                            {

                                for(var i=0;i<mesh['children'][0]['material'].length;i++)                               // 材质纹理取消透明
                                {
                                   // console.log(mesh['children'][0]['material'][i]['opacity']);
                                    mesh['children'][0]['material'][i]['transparent'] =false;
                                    //mesh['children'][0]['material'][i]['opacity'] = 0;

                                }

                                    console.log("优雅的退出房间   ----- 点击电视区域退出房间")
                                    // -0.8880877192072782,-0.5761502941342928,-1.130744562678091
                                    // -0.8802677042998384,-0.04991820897111332,-1.1113757947196676
                                    // -0.4203266577384608,-0.601510209665427,-1.9718166111677717
                                    // -0.4060523606258606,-0.03489494268334988,-1.9700081400208544
                                    new TWEEN.Tween(camera.position).to(
                                        {
                                            x: x - camera.getWorldDirection().x * 6,
                                            y: initY,
                                            z: z - camera.getWorldDirection().z * 6
                                        }, 2000)
                                        .easing(TWEEN.Easing.Quadratic.InOut)
                                        .start();
                                    isInHome = false;                                                                           //平滑退出房间
                                    controls.rotateSpeed = 0.3;
                            }
                           }                                                                                                        //点击非地面情况
                    }
                }

          // }                                                           // 强烈进入房间意图 才允许进入房间





        function  onWindowResize(){

            // windowHalfX = window.innerWidth/2;

            //  windowHalfY = window.innerHeight/2;

            camera.aspect = window.innerWidth / window.innerHeight;

            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth,window.innerHeight);

        }


        function onDocumentMouseMove (event ){

            //isMoveCount = 0;
            isMoveCount++;

            if(!isMove)isMove =true;

            if(isInHome == false)
            {                                                                                                            //鼠标室外移动

                   if(!isRotate) {
                       switch (intentInHome) {
                           case 0:
                               console.log("正在室外观察房屋");
                               break;
                           case -1: {
                               console.log("进入房间意图取消");
                               intentInHome = 0;
                           }
                               break;
                           case 1:
                               console.log("有初步进入房间意图");
                               break;
                           default:
                               break;
                       }                                                                                                //进入房间意图
                   }                                                                                   //不旋转模型移动鼠标情况

                        if(intentMouseRotate1 == 1)
                        {
                            console.log("正在室外旋转模型");
                            isRotate = true;
                        }

                    if(isMouseDown==true)
                    {

                    }

            }                                                                                                        //  室外移动鼠标情况
            else                                                                                                   //鼠标室内移动
            {
                   // console.log("-----鼠标在室内移动");
                    if(isMouseDown==true&&isMoveCount>=3)
                    {
                      //  console.log("正在室内观察房间   --------- 室外旋转模型，旋转方向:"+controls.rotateSpeed);
                       // console.log(controls.target);
                       // console.log("相机朝向 向量（xyz):"+camera.getWorldDirection().x+","+camera.getWorldDirection().y+","+camera.getWorldDirection().z);


                    }

                    if(isMouseDown==true&&isMoveCount==1)
                    {

                        intentMouseRotate1 = 1;
                       // console.log("有换角度观察房间意图（内）   --------  鼠标准备拖拽移动模型");
                    }
            }

        // console.log(isMoveCount);
            //  [-1,1]

            // console.log("camera.posiont xyz:"+camera.position.x+","+camera.position.y+","+camera.position.z);

            // console.log("control.target xyz:"+targetX+","+targetY+","+targetZ);

            //  console.log(controls.getAzimuthalAngle()+'--垂直--:::'+controls.getPolarAngle());

            mouse.x = (event.clientX / renderer.domElement.clientWidth )*2-1;

            mouse.y = -(event.clientY / renderer.domElement.clientHeight )*2+1;

            raycaster.setFromCamera(mouse,camera);  // camera  射线的起点     mouse 为鼠标移动所在的 二维坐标

            var intersects = raycaster.intersectObjects(mesh.children,true);//这里指的是房屋模型的所有对象

            if(intersects.length>0) {
                helperSphere.position.set(intersects[0].point.x, intersects[0].point.y, intersects[0].point.z);//  intersects[0]  这里表示射线与房屋模型对象的第一个交点     小球移动
                    intentInHome = 1;

                   // console.log("有进入房间意图" );
            }else
            {
                if(intentInHome==1)
                    intentInHome = -1;
            }




          //  console.log(intersects.length);


            //   console.log(rayPoint[i]);
            // console.log(helper[i]);
        }

    }


    function animate(){

        controls.update();
        requestAnimationFrame(animate);
        render();

    }


    function render(){

        TWEEN.update();
        //controls.update();
        renderer.render(scene,camera);

    }


</script>

</body>
</html>
